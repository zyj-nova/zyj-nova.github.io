<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="天空如此辽阔，大地不过是必经之路" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     张永剑的博客
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>


  

  

<link rel="alternate" href="/atom.xml" title="张永剑的博客" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      
<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-聚类" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/28/%E8%81%9A%E7%B1%BB/"
    >聚类</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/10/28/%E8%81%9A%E7%B1%BB/" class="article-date">
  <time datetime="2020-10-28T11:11:58.654Z" itemprop="datePublished">2020-10-28</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h2 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h2><p>参考：《机器学习》，2016，周志华；统计学习方法，李航。</p>
<h3 id="1-聚类指标度量"><a href="#1-聚类指标度量" class="headerlink" title="1. 聚类指标度量"></a>1. 聚类指标度量</h3><p>如何衡量簇（类）与簇之间的距离？</p>
<ul>
<li>平均距离（average linkage）</li>
<li>最大距离（complete linkage）</li>
<li>最小距离（single linkage）</li>
<li>中心距离</li>
</ul>
<p>如何衡量聚类效果的好坏？</p>
<h3 id="2-原型聚类"><a href="#2-原型聚类" class="headerlink" title="2. 原型聚类"></a>2. 原型聚类</h3><h4 id="2-1-K均值聚类"><a href="#2-1-K均值聚类" class="headerlink" title="2.1 K均值聚类"></a>2.1 K均值聚类</h4><p><strong>缺点</strong>：</p>
<ul>
<li>对初始化聚类中心敏感</li>
<li>K值难以指定</li>
<li>只能收敛于局部极小</li>
<li>对 outliers 噪声点敏感</li>
</ul>
<h4 id="2-2-高斯混合聚类"><a href="#2-2-高斯混合聚类" class="headerlink" title="2.2 高斯混合聚类"></a>2.2 高斯混合聚类</h4><h3 id="3-层次聚类"><a href="#3-层次聚类" class="headerlink" title="3. 层次聚类"></a>3. 层次聚类</h3><p><strong>算法描述</strong></p>
<ol>
<li>构造n个类，每个类只包含一个样本</li>
<li>计算n个类之间的距离，得到$n \times n$的距离矩阵$D$</li>
<li><strong>合并</strong>类间距离最小的两个类（注意：类间距离有不同的计算方式，可以根据情形来指定），形成一个新类。</li>
<li>计算新类与剩余类之间的距离，构造距离矩阵，若类别数等于k则算法结束，否则继续执行（3）。</li>
</ol>
<h3 id="4-密度聚类"><a href="#4-密度聚类" class="headerlink" title="4. 密度聚类"></a>4. 密度聚类</h3><p><strong>Density Based Spatial Clustering Applications with Noises</strong>（简称$\tt DBSCAN$）。</p>
<p>模型可视化：<a href="https://www.naftaliharris.com/blog/visualizing-dbscan-clustering/" target="_blank" rel="noopener">https://www.naftaliharris.com/blog/visualizing-dbscan-clustering/</a></p>
<h4 id="4-1-基本概念（白话版）"><a href="#4-1-基本概念（白话版）" class="headerlink" title="4.1 基本概念（白话版）"></a>4.1 基本概念（白话版）</h4><p><strong>参数</strong>：$\epsilon$ （阈值），$min Points$（点数量）</p>
<p><strong>核心对象：</strong>对于任一样本 $\pmb x\in D$，以 $\pmb x$ 为中心，半径为 $\epsilon$ 的圆内（领域）存在的其他样本数大于$min Points$，则 $\pmb x$ 为一个核心对象。（当然这里的“圆’指的是维数为2时，3维是球，更高维….反正就是与$\pmb x$距离小于$\epsilon$ 的）。</p>
<p><strong>直接密度可达（密度直达）：</strong>对于核心对象点 $\pmb x_i$，若 $\pmb x_j$ 在以 $\pmb x_i$ 为中心的圆内，则称 $\pmb x_j$ 由 $\pmb x_i$ 密度直达。</p>
<p><strong>密度可达：</strong> 若有一个样本序列，$\pmb x_0,\pmb x_1,…,\pmb x_k$，对任意$\pmb x_i, \pmb x_{i-1}$是<strong>密度直达</strong>的，则称从$\pmb x_0$ 到 $\pmb x_k$ 密度可达。</p>
<p>可以看出这条序列上的所有样本都是核心对象。这句话说的就是密度可达的传递性。图示：</p>
<p><img src="/images/dbscan.png" alt="image-20201028200926586"></p>
<p>上图中，红色的点都是密度直达的。$B、C$ 是密度相连的。</p>
<p>噪声点：从任何一个核心点都不密度可达。</p>
<h4 id="4-2-算法描述"><a href="#4-2-算法描述" class="headerlink" title="4.2 算法描述"></a>4.2 算法描述</h4><p>具体过程就像病毒的扩散过程一样，尽可能感染邻域内的点，当没有点可以感染，就再选一个没被感染的<strong>核心对象</strong>点继续感染，直到没有核心对象点了或者所有点都被感染了，算法停止。</p>
<p>输入：样本集$D=\{\pmb x_1,\pmb x_2,…,\pmb x_m\}$，领域参数$(\epsilon,min Points)$</p>
<p>输出：簇划分$C$</p>
<ol>
<li>标记所有样本D为unvisited</li>
<li>遍历所有样本点，初始化每个样本的邻域信息若某个对象邻域内样本数量大于minPoints, 加入核心对象集合$\Gamma$。</li>
<li>从核心对象集合随机选取一个核心对象p：<ol>
<li>创建一个核心对象队列$\Omega$，将$p$加入到其中</li>
<li>标记p为visited</li>
<li>创建一个簇C，将p添加到C中</li>
<li>当$\Omega$不为空：<ol>
<li>取出一个核心对象</li>
<li>遍历其邻域集合：<ol>
<li>若邻域内某样本q是核心对象<ol>
<li>将q加入到$\Omega$，从$\Gamma$中删去q</li>
</ol>
</li>
<li>否则如果 q 为unvisited：<ol>
<li>标记q为visited</li>
<li>将q加入到C</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>输出C</li>
</ol>
</li>
<li>D中unvisited的为噪声点</li>
</ol>
<ul>
<li>优势：</li>
</ul>
<ol>
<li>不需要指定簇的个数</li>
<li>擅长找到离群点</li>
<li>可以检测任意形状的簇</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>高维数据有些困难</li>
<li>参数难以选择</li>
</ol>
<h3 id="5-均值漂移（Mean-Shift）"><a href="#5-均值漂移（Mean-Shift）" class="headerlink" title="5. 均值漂移（Mean Shift）"></a>5. 均值漂移（Mean Shift）</h3>
      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      
      
    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-动态规划" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"
    >动态规划</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/10/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="article-date">
  <time datetime="2020-10-25T05:41:25.443Z" itemprop="datePublished">2020-10-25</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="0-导引"><a href="#0-导引" class="headerlink" title="0. 导引"></a>0. 导引</h3><p>一个问题能用动态规划解决，必须具有以下两个基本条件：</p>
<ul>
<li>最优子结构</li>
<li>重叠子问题</li>
</ul>
<p>算法导论中提到，<strong>动态规划有两种等价的实现方法。第一种是自底向上的递推迭代，第二种是带备忘录的自顶向下（带备忘录的递归，如果某个阶段已经计算过，那么直接结束递归）</strong>。</p>
<p>还有一个比较重要的是要求<strong>子问题间无后效性</strong>。有些问题可能不满足这个，或者证明比较麻烦。</p>
<p>下面看个例子。</p>
<script type="math/tex; mode=display">
W(a,b)=\left\{ \begin{array}{rcl}
1     &     & a\leq 0\ or\ b\le0\\
W(a-1,b-1)+W(a,b-1)&     & {a < b}\\
W(a-1,b-1)+W(a-1,b)&     & {a\ge b}\\
\end{array}
\right.</script><p>根据这个递归公式，</p>
<ul>
<li>自底向上：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">W</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= a; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= b; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> dp[a][b];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>带备忘录的自顶向下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">W</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt;= <span class="number">0</span> || b &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dp[a][b] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[a][b];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(a &lt; b)&#123;</span><br><span class="line">        dp[a][b] = W(a - <span class="number">1</span>, b - <span class="number">1</span>) + W(a, b - <span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        dp[a][b] = W(a - <span class="number">1</span>, b - <span class="number">1</span>) + W(a - <span class="number">1</span>, b);</span><br><span class="line">    <span class="keyword">return</span> dp[a][b];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多练习，<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1579" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1579</a></p>
<h3 id="1-最大子段和"><a href="#1-最大子段和" class="headerlink" title="1. 最大子段和"></a>1. 最大子段和</h3><p>状态转移方程：</p>
<script type="math/tex; mode=display">
\tt dp[i] = \max(\tt num[i],\tt dp[i-1]+num[i])</script><p>$\tt dp[i]$表示到以第 $\tt i$ 个元素结尾的最大子连续段和。</p>
<p>leetcode 53号问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="comment">//第i个dp元素代表以i结尾的最大连续子序和</span></span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>] + nums[i],nums[i]);</span><br><span class="line">            ans = Math.max(ans,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-最长上升子序列"><a href="#2-最长上升子序列" class="headerlink" title="2. 最长上升子序列"></a>2. 最长上升子序列</h3><p>状态转移方程：</p>
<script type="math/tex; mode=display">
\tt dp[i] = max(\tt dp[j]+1,dp[i]),\tt  if\ j < i\ and\ num[j] < num[i]</script><p>$\tt dp[i]$表示以第 $\tt i$ 个元素结尾的序列的最长上升子序列。</p>
<p>$\tt Leetcode$ 第300号题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);<span class="comment">//理解+1操作</span></span><br><span class="line">                    max = Math.max(dp[i], max);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>进阶：</strong>编写算法，求出一个数字序列中最长递增子序列的<strong>个数</strong>。这是Leetcode 673号问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNumberOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//需要利用一个counter数组记录每个数字的最长递增序列的组合数是多少</span></span><br><span class="line">        <span class="keyword">int</span> counter[] = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">         <span class="keyword">int</span> maxn = -<span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            counter[i] = <span class="number">1</span>;<span class="comment">//自身为一个序列，只有一种组合数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i])&#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[j] + <span class="number">1</span> &gt; dp[i])&#123;</span><br><span class="line">                        dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                        counter[i] = counter[j];</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (dp[j] + <span class="number">1</span> == dp[i])&#123;</span><br><span class="line">                        counter[i] += counter[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxn = Math.max(dp[i], maxn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == maxn)&#123;</span><br><span class="line">                res += counter[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-最长公共子序列-lcs"><a href="#3-最长公共子序列-lcs" class="headerlink" title="3. 最长公共子序列(lcs)"></a>3. 最长公共子序列(lcs)</h3><p>状态转移方程：</p>
<script type="math/tex; mode=display">
dp(i,j)=\left\{ \begin{array}{rcl}
dp[i-1][j-1]+1     &     & s1[i]=s2[j]\\
\max(dp[i-1][j],dp[i][j-1])&     & s1[i]\not=s2[j]\\
\end{array}
\right.\\</script><p><strong>提高：现在不仅要求出最长公共子序列的长度，还要求输出最长公共子序列，该怎么办？</strong></p>
<p>题目链接：<a href="http://www.51nod.com/Challenge/Problem.html#problemId=1006" target="_blank" rel="noopener">http://www.51nod.com/Challenge/Problem.html#problemId=1006</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>], flag[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">1005</span>],s2[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLCS</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;= <span class="number">0</span> || j &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">        printLCS(i<span class="number">-1</span>,j<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s1[i<span class="number">-1</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">        printLCS(i<span class="number">-1</span>,j);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        printLCS(i,j<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(s1), len2 = <span class="built_in">strlen</span>(s2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= len2; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                flag[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j] &gt; dp[i][j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                    flag[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-1</span>];</span><br><span class="line">                    flag[i][j] = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printLCS(len1,len2);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要一个数组记录每次的最大值是从哪个状态转移过来的，要输出的时候，使用递归函数，自顶向下递归，从里到外打印输出。</p>
<p><strong>进阶：</strong>现在还要求出两个字符串最长公共子序列的个数有多少？<a href="https://www.luogu.com.cn/problem/P2516" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P2516</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 5010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 100000000</span></span><br><span class="line"><span class="keyword">char</span> A[maxn],B[maxn],cur;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][maxn], g[<span class="number">2</span>][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, A + <span class="number">1</span>, B + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> na = <span class="built_in">strlen</span>(A + <span class="number">1</span>), nb = <span class="built_in">strlen</span>(B + <span class="number">1</span>);</span><br><span class="line">    A[na--] = <span class="string">'\0'</span>; B[nb--] = <span class="string">'\0'</span>;</span><br><span class="line">    cur=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nb; i++) g[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    g[<span class="number">0</span>][<span class="number">0</span>] = g[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= na; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cur ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nb; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] == B[j]) </span><br><span class="line">                f[cur][j] =f[cur^<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                f[cur][j] = <span class="built_in">max</span>(f[cur^<span class="number">1</span>][j], f[cur][j<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">            g[cur][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(f[cur][j] == f[cur^<span class="number">1</span>][j]) </span><br><span class="line">                g[cur][j] += g[cur^<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(f[cur][j] == f[cur][j<span class="number">-1</span>]) </span><br><span class="line">                g[cur][j] += g[cur][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(f[cur][j] == f[cur^<span class="number">1</span>][j] &amp;&amp; f[cur][j] == f[cur][j<span class="number">-1</span>] &amp;&amp; f[cur^<span class="number">1</span>][j<span class="number">-1</span>] == f[cur][j])</span><br><span class="line">                g[cur][j] -= g[cur^<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(A[i] == B[j] &amp;&amp; f[cur][j] == f[cur^<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">1</span>) </span><br><span class="line">                g[cur][j] += g[cur^<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(g[cur][j] &gt; MOD) </span><br><span class="line">                g[cur][j] %= MOD;</span><br><span class="line">            <span class="keyword">if</span>(g[cur][j] &lt; <span class="number">0</span>) </span><br><span class="line">                g[cur][j] = (g[cur][j] % MOD) + MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>, f[cur][nb], g[cur][nb]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-最长公共子串-lc"><a href="#4-最长公共子串-lc" class="headerlink" title="4. 最长公共子串(lc)"></a>4. 最长公共子串(lc)</h3><p>状态转移方程：</p>
<script type="math/tex; mode=display">
\tt dp[i][j] = dp[i-1][j-1]+ 1,when\ str1[i-1]=str2[j-1]</script><script type="math/tex; mode=display">
\tt i\ from\ 0\ to\ len(str1),j\ from\ 0\ to\ len(str2)</script><p>$\tt dp[i][j]$表示str1前i个字符与str2前j个字符的最长公共子串。</p>
<h3 id="5-背包问题"><a href="#5-背包问题" class="headerlink" title="5. 背包问题"></a>5. 背包问题</h3><p>参考文献：背包问题九讲，崔添翼。</p>
<h4 id="5-1-0-1背包"><a href="#5-1-0-1背包" class="headerlink" title="5.1 0-1背包"></a>5.1 0-1背包</h4><p><strong>问题描述：</strong>给定容量为 $V$ 的背包，有 $n$ 个物品，每个物品有价值 $w$、体积 $c$ 两个属性，求背包能装的物品最大价值。</p>
<p><strong>求解：</strong>二维数组 $dp$，$dp[i][j]$ 表示有 $i$ 个物品，背包容量为 $j$ 的情况下，此时的背包最大价值；$dp[n][V]$即为答案</p>
<p>状态转移公式：</p>
<script type="math/tex; mode=display">
dp[i][j] = \max(dp[i-1][j], dp[i-1][j - c[i]] + w[i])</script><p><strong>理解状态转移公式</strong>：</p>
<p>对于每个背包都有两种选择：装与不装（装的前提是当前容量 $j$ 能装下 $c[i]$），不装的话就是前 $i-1$ 个物品容量为 $j$ 时的价值 $dp[i][j]$；若选择装，则背包需要提前给当前物品留下 $c[i]$ 的空间。</p>
<p>代码实现（杭电2602号问题）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, V;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>], v[<span class="number">1005</span>], w[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;V);</span><br><span class="line">        <span class="comment">// 输入n件物品的价值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输入n件物品的体积</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp[i][j]代表了到第i个物品，背包容量为j时的最大价值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= w[i])&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j - w[i]] + v[i], dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[n][V]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>空间压缩：</strong></p>
<script type="math/tex; mode=display">
dp[j] = \max(dp[j], dp[j - c[i]] + w[i])</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, V;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>], v[<span class="number">1005</span>], w[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;V);</span><br><span class="line">        <span class="comment">// 输入n件物品的价值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="comment">// 输入n件物品的体积</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp[j]代表背包容量为j时的最大价值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j &gt;= w[i]; j--)&#123;<span class="comment">//注意逆序</span></span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[V]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>初始化的细节问题</strong></p>
<ul>
<li><p>当有些问题要求“恰好装满背包”时的最优解，这时在初始化的时候，dp数组除了dp[0]为0，其余dp[1…V]均设置为无穷大。可以这样理解：初始化的dp数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为$0$的背包可以在什么也不装且价值为 $0$ 的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，应该被赋值为无穷大了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。</p>
</li>
<li><p>还有一种情况就是求背包的最小价值，把转移方程中的$max$改为$min$即可。</p>
</li>
<li>有些题目中，只给了价值或者重量这一个数组，那么此时我们可以认为数值上价值与重量时一致的。比如只给了价值 $v$，此时01背包状态转移公式就成了：$dp[j+1] = \max(dp[j],dp[j - v[i]] + v[i]),j \in [V,v[i]]] $。</li>
</ul>
<p>杭电1114号问题就是以上两种情况的结合。题目大意就是给定存钱罐初始重量和装满时候的重量，然后给定几种不同价值和重量的硬币，问能够恰好装满存钱罐的最小价值是多少？每个种类的硬币可以无限使用，这是一个<strong>完全背包问题</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> m, n, t, N;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">502</span>], w[<span class="number">502</span>]; <span class="comment">// 硬币价值 和 硬币重量数组</span></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">    <span class="keyword">while</span>(N--)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入初始存钱罐重量和现在存钱罐重量</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m, &amp;n);</span><br><span class="line">        <span class="keyword">int</span> V = n - m; <span class="comment">// 钱币重量</span></span><br><span class="line">        <span class="comment">// 输入硬币种类</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;v[i], &amp;w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意初始化</span></span><br><span class="line">        <span class="built_in">memset</span>(dp, inf, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找到恰好能装满存钱罐重量的钱币价值中最小的那个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = w[i]; j &lt;= V; j++)&#123;<span class="comment">// 注意这是顺序</span></span><br><span class="line">                dp[j] = min(dp[j - w[i]] + v[i], dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[V] == inf)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"This is impossible.\n"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"The minimum amount of money in the piggy-bank is %d.\n"</span>,dp[V]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Leetcode 416号问题：划分等和子集。</li>
</ul>
<p>给定一个<strong>只包含正整数</strong>的<strong>非空</strong>数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p><strong>注意:</strong></p>
<ol>
<li>每个数组中的元素不会超过 100</li>
<li>数组的大小不会超过 200</li>
</ol>
<p>事实上这是个$NP$难问题，但在给定的数据规模下，可以转化为0-1背包问题求解。具体就是：给定n件物品，背包容量为 sum / 2 能否选择一些物品，恰好装满背包？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 转为01背包问题；给定n件物品，背包容量为 sum / 2 能否选择一些物品，恰好装满背包</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((sum &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;<span class="comment">//总和为奇数，一定不可以对半分</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>; <span class="comment">// 背包容量</span></span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>  j = target; j &gt;= nums[i]; j--)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-完全背包"><a href="#5-2-完全背包" class="headerlink" title="5.2 完全背包"></a>5.2 完全背包</h4><p><strong>定义</strong></p>
<p>有 $N$ 种物品和一个容量为 $V$ 的背包，每种物品都有<strong>无限件</strong>可用。放入第 $i$ 种物品的费用是 $c_i$，价值是 $w_i$。求解：将哪些物品装入背包，可使这些物品的耗费的费用总和不超过背包容量，且价值总和最大。</p>
<p><strong>求解</strong></p>
<p>虽然物品个数是无限的，但是实际上，由于背包容量有上限，每个物品最多选取的个数也是有限制的，这样可以转换成多重背包问题，进而可以转换成 01 背包问题。</p>
<script type="math/tex; mode=display">
dp[i][j] = \max(dp[i-1][j-kc_i] + kw_i|0 \le kc_i \le j)</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= v; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k*c[i] &lt;= j; k++)&#123;</span><br><span class="line">            dp[i][j] = max(dp[i<span class="number">-1</span>][j - k * c[i]] + w[i] * k, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察状态转移公式，我们可以用$dp[i][j - c_i]$去更新$dp[i][j]$而不用去枚举$k$了，因此状态转移公式就变成：</p>
<script type="math/tex; mode=display">
dp[i][j] = \max(dp[i-1][j],dp[i-1][j-c_i]+w_i)</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= v; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= c[i])&#123;</span><br><span class="line">            dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-c[i]] + w[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>空间压缩</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">21</span>],c[<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, V;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; V;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = c[i]; j &lt;= V; j++)&#123; <span class="comment">// 顺序</span></span><br><span class="line">            dp[j] = max(dp[j- c[i]] + w[i],dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可以看到完全背包就是在第二重循环遍历次序与01背包不同而已，01背包是逆序，完全背包是顺序。</strong></p>
<h4 id="5-3-多重背包"><a href="#5-3-多重背包" class="headerlink" title="5.3 多重背包"></a>5.3 多重背包</h4><p><strong>定义</strong></p>
<p>有 $N$ 种物品和一个容量为 $V$ 的背包。第 $i$ 种物品最多有 $n_i$ 件可用，每件耗费的空间是 $c_i$，价值是 $w_i$。求解将哪些物品装入背包可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。</p>
<p><strong>求解</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">21</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">21</span>],c[<span class="number">21</span>],n[<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,V;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; V;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; c[i] &gt;&gt; n[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;  k &lt;= n[i]; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= c[i]*k)&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j - c[i]*k] + w[i]*k, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[N][V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>空间优化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">21</span>],c[<span class="number">21</span>],n[<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,V;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; V;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; c[i] &gt;&gt; n[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n[i]; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= c[i]*k)&#123;</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j - c[i]*k] + w[i] * k,dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>多重背包的二进制优化</strong></p>
<p>二进制思想即任意数字都可以由$2$的次幂的数字组合而来（用01表示），这是计算机的基础。利用这个思想，我们可以把每个物品数量分成$1,2,4,…,n - 2^K + 1$，每一组的体积和价值分别为$(c_i，w_i),(2c_i,2w_i)，(4c_i，4w_i)$，等等，通过这些组合（选择装与不装）一定可以组成$n$，这样就遍历了$1-n$内所有数字。通过拆分所有物品，就形成了一个新的价值和体积物品组，这些问题组我们可以选择装也可以选择不装，这样利用二进制优化就可以将多重背包转化为01背包问题。</p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二进制优化</span></span><br><span class="line"><span class="keyword">int</span> ncnt = <span class="number">1</span>; <span class="comment">// 记录新的拆分组数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++)&#123; <span class="comment">// t个物品</span></span><br><span class="line">    <span class="comment">// 将num[i]拆分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= num[i]; k &lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        nv[ncnt] = k * v[i];<span class="comment">//新拆分的价值数组</span></span><br><span class="line">        nw[ncnt++] = k * w[i];<span class="comment">//新拆分的重量数组</span></span><br><span class="line">        num[i] -= k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        nv[ncnt] = v[i] * num[i];</span><br><span class="line">        nw[ncnt++] = w[i] * num[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 01背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ncnt; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j &gt;= nw[i]; j--)&#123;</span><br><span class="line">        dp[j] = max(dp[j - nw[i]] + nv[i], dp[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>杭电1059、2844号题是完全背包的二进制优化。</p>
<h4 id="5-4-有约束的背包问题"><a href="#5-4-有约束的背包问题" class="headerlink" title="5.4 有约束的背包问题"></a>5.4 有约束的背包问题</h4><p>杭电3466号问题。题目大意是说，给定背包容量，每个物品的重量$P$，若要装入该物品要求的最小背包容量$Q$以及该物品的价值$V$，输出不超过背包容量下所能获取的最大物品价值。</p>
<p>相比于裸01背包，这个题目要求装入的时候必须考虑$P,Q$这两个条件，要用到贪心。即$A$物品$p_1=3,q_1=5$，$B$物品$p_2=4,q_2=3$；背包容量为$7$，若先装$A$，所需容量至少为$p_1 + q_2 = 7$，若先装$B$，所需容量至少为$p_2 + q_1 = 9$，因此应该选择容量小的。即：$p_1 + q_2 &lt; p_2 + q_1 \rightarrow q_1-p_1 &gt; q_2 - p_2$，即$q-p$大的先买。但是转移方程中，更新过程是逆向的，因此排序的时候应该按照$p-q$从小到大排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, V, dp[<span class="number">5005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">item</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> p,q,v;</span><br><span class="line">&#125;items[<span class="number">5005</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(struct item a, struct item b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.q - a.p &lt; b.q - b.p; <span class="comment">// 按照 q-p 从小到大排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;V))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="comment">// p就是物品的重量 v是物品的价值， 背包容量必须大于p和q才能装入</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;items[i].p, &amp;items[i].q, &amp;items[i].v);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(items + <span class="number">1</span>, items + <span class="number">1</span> + n, cmp);</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j &gt;= <span class="built_in">max</span>(items[i].p, items[i].q); j--)&#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - items[i].p] + items[i].v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[V]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>背包练习(以下题目皆来自杭电 on-line judge: <a href="http://acm.hdu.edu.cn/" target="_blank" rel="noopener">http://acm.hdu.edu.cn/</a> ，做完还不会背包来找我。</p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2602" target="_blank">2602</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1114" target="_blank">1114</a>  <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1171" target="_blank">1171</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2844" target="_blank">2844</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1059" target="_blank">1059</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2955" target="_blank">2955</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1203" target="_blank">1203</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3466" target="_blank">3466</a></p>
<h3 id="6-编辑距离"><a href="#6-编辑距离" class="headerlink" title="6. 编辑距离"></a>6. 编辑距离</h3><p>问题描述：</p>
<p>给你两个单词word1和word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/edit-distance" target="_blank" rel="noopener">https://leetcode-cn.com/problems/edit-distance</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>视频讲解：<a href="https://www.youtube.com/watch?v=MiqoA-yF-0M" target="_blank" rel="noopener">https://www.youtube.com/watch?v=MiqoA-yF-0M</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = word1.length();</span><br><span class="line">        <span class="keyword">int</span> m = word2.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">// 前三种情况</span></span><br><span class="line">                dp[i][j] = Math.min(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, Math.min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line">                <span class="comment">// 第四种情况</span></span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-区间DP"><a href="#7-区间DP" class="headerlink" title="7. 区间DP"></a>7. 区间DP</h3><p><strong>概述：</strong>区间类动态规划是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来由很大的关系。令状态 $f(i,j)$ 表示将下标位置 $i$ 到 $j$ 的所有元素合并能获得的价值的最大（最小）值，那么 $f(i,j) = \max\{f(i,k) + f(k+1,j) + cost\}$，$cost$ 为将这两组元素合并起来的代价。</p>
<p><strong>求解：</strong>对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。</p>
<h4 id="7-1-矩阵相乘的最少次数"><a href="#7-1-矩阵相乘的最少次数" class="headerlink" title="7.1 矩阵相乘的最少次数"></a>7.1 矩阵相乘的最少次数</h4><p><a href="https://onlinejudge.u-aizu.ac.jp/problems/ALDS1_10_B" target="_blank" rel="noopener">https://onlinejudge.u-aizu.ac.jp/problems/ALDS1_10_B</a></p>
<p>本质上是在填一张表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line">&#125;matrices[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; matrices[i].row &gt;&gt; matrices[i].col;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//填表：自左向右，自下而上 只要填写上半部分</span></span><br><span class="line">        <span class="comment">// dp[i,j] = min&#123;dp[i:k] + dp[k+1:j] + row_i * p * col_j&#125; i &lt;= k &lt; j</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;<span class="comment">//从左到右</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--)&#123;<span class="comment">//自下而上</span></span><br><span class="line">                <span class="keyword">if</span>(i == j)&#123;<span class="comment">// 对角线元素 dp[i][i] = 0</span></span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i - j == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">// i矩阵与j矩阵相乘：</span></span><br><span class="line">                    dp[j][i] = matrices[j].row * matrices[j].col * matrices[i].col;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[j][i] = <span class="number">2</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; i; k++)&#123;</span><br><span class="line">                        <span class="keyword">int</span> t = matrices[j].row * matrices[k].col * matrices[i].col;</span><br><span class="line">                        dp[j][i] = <span class="built_in">min</span>(dp[j][k] + dp[k+<span class="number">1</span>][i] + t,dp[j][i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[<span class="number">1</span>][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-2-石子合并"><a href="#7-2-石子合并" class="headerlink" title="7.2 石子合并"></a>7.2 石子合并</h4><p><a href="https://vjudge.net/problem/51Nod-1021" target="_blank" rel="noopener">https://vjudge.net/problem/51Nod-1021</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">205</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2</span> &lt;&lt; <span class="number">21</span>;</span><br><span class="line"><span class="comment">// dp[i][j]表示区间[i,j]所能形成的最优答案</span></span><br><span class="line"><span class="keyword">int</span> n, nums[maxn], dp[maxn][maxn], sum[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; nums[i];</span><br><span class="line">        tmp += nums[i];</span><br><span class="line">        sum[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            dp[i][j] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; len++)&#123;<span class="comment">//枚举区间长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++)&#123;<span class="comment">//枚举区间起点</span></span><br><span class="line">            <span class="keyword">int</span> j = i + len - <span class="number">1</span>;<span class="comment">//区间终点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; k++)&#123;<span class="comment">//枚举分割点</span></span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k+<span class="number">1</span>][j] + sum[j] - sum[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[<span class="number">1</span>][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-3-Dire-Wolf"><a href="#7-3-Dire-Wolf" class="headerlink" title="7.3 Dire Wolf"></a>7.3 Dire Wolf</h4><p>杭电：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5115" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=5115</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, t, a[<span class="number">205</span>], b[<span class="number">205</span>], dp[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2</span> &lt;&lt; <span class="number">25</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    dp[i][j] 代表 i 到 j的狼被杀死 所受的最小伤害，结果就是dp[0][n-1]</span></span><br><span class="line"><span class="comment">    当 1 &lt; i &lt; t ,每条狼的攻击力 a[i] + b[i-1] + b[i+1]</span></span><br><span class="line"><span class="comment">    当这只狼被打败，那么他给邻接的狼提供的攻击力会失效</span></span><br><span class="line"><span class="comment">    考虑没有附加攻击的情况，无论怎么打都是所有a求和，</span></span><br><span class="line"><span class="comment">    现在添加了b，本质上是要我们选择使附加攻击最小的一种方案。</span></span><br><span class="line"><span class="comment">    通过样例我们可以总结出来如果有附带伤害高的狼先杀他，</span></span><br><span class="line"><span class="comment">    然后尽量杀两端的狼，这样只有一边有附带伤害</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cnt = <span class="number">0</span>; cnt &lt; n; cnt++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">            <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">            <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++)&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++)&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= t; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= t; j++)&#123;</span><br><span class="line">                    dp[i][j] = INF;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= t; len++)&#123;<span class="comment">// 枚举区间长度</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= t; i++)&#123;<span class="comment">//枚举区间起点</span></span><br><span class="line">                    <span class="keyword">int</span> j = i + len - <span class="number">1</span>;<span class="comment">//终点</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; k++)&#123;<span class="comment">//枚举分割点</span></span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(dp[i][j],dp[i][k<span class="number">-1</span>] + dp[k+<span class="number">1</span>][j] + a[k] + b[i<span class="number">-1</span>] + b[j+<span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case #%d: %d\n"</span>,cnt+<span class="number">1</span>,dp[<span class="number">1</span>][t]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-4-Brackets"><a href="#7-4-Brackets" class="headerlink" title="7.4 Brackets"></a>7.4 Brackets</h4><p>题目链接：<a href="https://vjudge.net/problem/POJ-2955" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2955</a></p>
<p>状态转移方程：当<code>s[i]=&#39;(&#39; \ and\ s[j]==&#39;)&#39;\ or\ s[i]=&#39;[&#39; \ and\ s[j]==&#39;]&#39;</code> 时，<code>dp[i][j] = dp[i+1][j-1] + 2;</code>还有就是<code>dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j]);</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>];<span class="comment">//表示区间dp[i][j]表示[i,j]内的最大匹配数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; ch &amp;&amp; <span class="built_in">strcmp</span>(ch,<span class="string">"end"</span>)!= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(ch);</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">2</span>; t &lt;= len; t++)&#123;<span class="comment">//枚举区间长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + t - <span class="number">1</span> &lt; len; i++)&#123;<span class="comment">//枚举区间起点</span></span><br><span class="line">                <span class="keyword">int</span> j = i + t - <span class="number">1</span>;<span class="comment">//区间终点</span></span><br><span class="line">                <span class="keyword">if</span>((ch[i] == <span class="string">'('</span> &amp;&amp; ch[j] == <span class="string">')'</span>) || (ch[i] == <span class="string">'['</span> &amp;&amp; ch[j] == <span class="string">']'</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; k++)&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][k] + dp[k+<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[<span class="number">0</span>][len<span class="number">-1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      
      
    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-机器视觉基础Lecture1" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/21/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E5%9F%BA%E7%A1%80Lecture1/"
    >机器视觉基础Lecture1</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/10/21/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E5%9F%BA%E7%A1%80Lecture1/" class="article-date">
  <time datetime="2020-10-21T12:34:34.100Z" itemprop="datePublished">2020-10-21</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E5%9F%BA%E7%A1%80/">机器视觉基础</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h2 id="机器视觉基础-Lecture-1"><a href="#机器视觉基础-Lecture-1" class="headerlink" title="机器视觉基础 Lecture 1"></a>机器视觉基础 Lecture 1</h2><h3 id="1-卷积"><a href="#1-卷积" class="headerlink" title="1. 卷积"></a>1. 卷积</h3><p>卷积操作即用一个窗口在图像上滑动，图像上的像素与窗口内的数值相乘再相加，最后得到新的图像的过程；这个窗口也被称为滤波器/核。</p>
<p><strong>卷积运算的性质</strong>：</p>
<ul>
<li>交换律：$a <em> b = b </em> a$</li>
<li>结合律：$a <em> (b </em> c) = (a <em> b) </em> c$</li>
<li>分配律：$a<em>(b + c) = a</em>b + a*c$</li>
<li>数乘：$ka<em>b = a </em> kb = k(a*b)$</li>
</ul>
<p>可以看出，卷积运算是一种<strong>线性</strong>运算。</p>
<p><strong>Question</strong>：</p>
<ul>
<li><p>设计一个窗口，卷积过后图像保持不变</p>
<p><img src="/images/k1.jpg" alt="image-20201019182152123"></p>
</li>
</ul>
<ul>
<li><p>设计一个窗口，卷积过后图像向左平移1像素</p>
<p><img src="/images/k2.png" alt="image-20201019182236198"></p>
</li>
</ul>
<p>  思考：为什么？对于每一个中心点像素，卷积过后更新为右边像素点像素值，整幅图卷积完就会向左平移。</p>
<ul>
<li><p>设计一个窗口，卷积过后达到锐化（sharpen）的效果</p>
<p><img src="/images/k3.png" alt="image-20201019182428504"></p>
</li>
</ul>
<p>  思考：为什么要这么设计？</p>
<p>  步骤1：</p>
<p>  <img src="/images/f1.png" alt="image-20201019182727419"></p>
<p>  步骤2：</p>
<p>  <img src="/images/f2.png" alt="image-20201019182746490"></p>
<p>  综合步骤1、2可以看出，相当于将原来的像素值乘2再减去均值滤波平滑后的图像，就可以得到锐化后的图像。写成卷积核形式就是上述形式。</p>
<h3 id="2-各种滤波器"><a href="#2-各种滤波器" class="headerlink" title="2. 各种滤波器"></a>2. 各种滤波器</h3><h4 id="2-1-均值滤波"><a href="#2-1-均值滤波" class="headerlink" title="2.1 均值滤波"></a>2.1 均值滤波</h4><p>会出现“振零”现象。</p>
<h4 id="2-2-高斯滤波"><a href="#2-2-高斯滤波" class="headerlink" title="2.2 高斯滤波"></a>2.2 高斯滤波</h4><p>如何生成一个高斯滤波器？高斯函数（连续）：$G(x,y)=e^{-\frac{x^2+y^2}{\sigma^2}}$到卷积核（离散）。</p>
<p>matlab生成$\sigma=1$和$\sigma=3$的高斯核（归一化后的）：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.0030</span>    <span class="number">0.0133</span>    <span class="number">0.0219</span>    <span class="number">0.0133</span>    <span class="number">0.0030</span></span><br><span class="line"><span class="number">0.0133</span>    <span class="number">0.0596</span>    <span class="number">0.0983</span>    <span class="number">0.0596</span>    <span class="number">0.0133</span></span><br><span class="line"><span class="number">0.0219</span>    <span class="number">0.0983</span>    <span class="number">0.1621</span>    <span class="number">0.0983</span>    <span class="number">0.0219</span></span><br><span class="line"><span class="number">0.0133</span>    <span class="number">0.0596</span>    <span class="number">0.0983</span>    <span class="number">0.0596</span>    <span class="number">0.0133</span></span><br><span class="line"><span class="number">0.0030</span>    <span class="number">0.0133</span>    <span class="number">0.0219</span>    <span class="number">0.0133</span>    <span class="number">0.0030</span></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.0318</span>    <span class="number">0.0375</span>    <span class="number">0.0397</span>    <span class="number">0.0375</span>    <span class="number">0.0318</span></span><br><span class="line"><span class="number">0.0375</span>    <span class="number">0.0443</span>    <span class="number">0.0469</span>    <span class="number">0.0443</span>    <span class="number">0.0375</span></span><br><span class="line"><span class="number">0.0397</span>    <span class="number">0.0469</span>    <span class="number">0.0495</span>    <span class="number">0.0469</span>    <span class="number">0.0397</span></span><br><span class="line"><span class="number">0.0375</span>    <span class="number">0.0443</span>    <span class="number">0.0469</span>    <span class="number">0.0443</span>    <span class="number">0.0375</span></span><br><span class="line"><span class="number">0.0318</span>    <span class="number">0.0375</span>    <span class="number">0.0397</span>    <span class="number">0.0375</span>    <span class="number">0.0318</span></span><br></pre></td></tr></table></figure>
<p>一般设计的高斯滤波默认均值为0，并且根据“3$\sigma$原则”，窗口大小可以根据方差$\sigma$来设定，因此高斯滤波通常只指定一个参数：方差$\sigma$。</p>
<p><strong>3$\sigma$原则</strong>：一维高斯函数我们可以发现，在以原点为中心，向左向右$3|\sigma|$距离内，函数积分可以达到$99.73\%$，也就是说$|x|&gt;3\sigma$的点几乎约等于0，对卷积没有什么贡献。因此设计卷积核的时候。</p>
<p><strong>窗口大小一定，方差$\sigma$对平滑效果的影响：$\sigma$越大，平滑效果越明显。</strong></p>
<p>高斯函数的特点是：$\sigma$越小越集中（函数图像越尖，中心点的权值越大），这样加权平均自身权重更大，当$\sigma$逐渐增大，自身权重变小，加权过后自身信息丧失更加严重。</p>
<p><strong>方差一定且在3$\sigma$原则下，窗口大小对平滑效果的影响：窗口越大，平滑效果越明显。</strong></p>
<p>下面两张图展示了$\sigma=3$的情况下，窗口值大小为$3、9$的滤波结果。</p>
<p><img src="/images/var3_kernelsize_3.jpg" style="zoom:80%;" /></p>
<p><img src="/images/var3_kernelsize_9.jpg" style="zoom:80%;" /></p>
<p>窗口加大需要考虑的像素值越多自身信息丧失的也就越多。要求限定$3\sigma$原则原因是，超过这个范围，无论窗口多大平滑效果几乎一致（最外围差不多都是0了，对加权求和没有贡献）。</p>
<p>高斯噪声：采样于均值为0，方差为$\sigma$的高斯函数的值加到源图像上。</p>
<p>二维高斯函数（均值都是0）：</p>
<script type="math/tex; mode=display">
G(x,y) = \frac{1}{ {2\pi\sigma^2}}e^{-\frac{x^2+y^2}{2\sigma^2}} = G(x)G(y)</script><script type="math/tex; mode=display">
G_x(x,y) = \frac{\partial G}{\partial x} =-\frac{1}{2\pi\sigma^2}\frac{x}{\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}</script><script type="math/tex; mode=display">
G_y(x,y)=\frac{\partial G}{\partial y} =-\frac{1}{2\pi\sigma^2}\frac{y}{\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}</script><script type="math/tex; mode=display">
G_{xx}(x,y) =-\frac{1}{2\pi\sigma^2}(\frac{1}{\sigma^2}-\frac{x^2}{\sigma^4})e^{-\frac{x^2+y^2}{2\sigma^2}}</script><script type="math/tex; mode=display">
G_{yy}(x,y) =-\frac{1}{2\pi\sigma^2}(\frac{1}{\sigma^2}-\frac{y^2}{\sigma^4})e^{-\frac{x^2+y^2}{2\sigma^2}}</script><p>Laplacian of Gaussian (LoG)定义如下：</p>
<script type="math/tex; mode=display">
LoG = \frac{\partial^2 G}{\partial x^2} + \frac{\partial^2 G}{\partial y^2} = G_{xx}(x,y) + G_{yy}(x,y) = \frac{1}{2\pi\sigma^2}\frac{x^2 + y^2-2\sigma^2}{\sigma^4}e^{-\frac{x^2+y^2}{2\sigma^2}}</script><p>当用LoG核与图像做卷积会发现信号衰减，因此通常乘以$\sigma^2$ 做一下scale normaliz ation。</p>
<p>一个近似于该函数的离散卷积核($\sigma=1.4$)：</p>
<p><img src="https://homepages.inf.ed.ac.uk/rbf/HIPR2/figs/logdisc.gif" alt=""></p>
<p><strong>一维一阶</strong>高斯导数如下图所示（省略了系数$1/\sqrt{2\pi\sigma^2}$）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">-6</span>,<span class="number">6</span>,<span class="number">1000</span>)</span><br><span class="line">sigma_1 = <span class="number">1.0</span></span><br><span class="line">g_prime = -x/sigma_1**<span class="number">2</span> * np.exp(-x**<span class="number">2</span> / <span class="number">2</span> / sigma_1 ** <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/images/dergaussian.png" alt=""></p>
<p>一维二阶高斯导数如下图所示：</p>
<p><img src="C:\Users\zhang\Desktop\下载 (2" alt="">.png)</p>
<p><strong>将高斯函数离散化就可以得到高斯卷积核、一阶高斯卷积核</strong>。</p>
<p>在图像上，用高斯滤波就是取一个窗口，窗口内以中心点为（0,0）点然后给窗口内的不同坐标的窗口带入高斯函数中取值归一化后，在图像上滑动做卷积。</p>
<p>用高斯一阶导去和信号做卷积，干了两件事：一是平滑信号，二是求导。相当于先用高斯滤波平滑再求导。 同理高斯二阶导 Laplacian of Gaussian，用高斯二阶导去和信号卷积。</p>
<p>高斯差分 DoG （Difference of Gaussian）相当于一个核（滤波器）。下图显示两个正态分布（均值都为1）的函数图像以及二者的差值图像，即DoG。参考：<a href="http://fourier.eng.hmc.edu/e161/lectures/gradient/node9.html" target="_blank" rel="noopener">http://fourier.eng.hmc.edu/e161/lectures/gradient/node9.html</a></p>
<p><img src="http://fourier.eng.hmc.edu/e161/lectures/gradient/img111.png" alt=""></p>
<p><img src="http://fourier.eng.hmc.edu/e161/lectures/gradient/img112.png" alt=""></p>
<p><img src="/images/dog.png" alt=""></p>
<ul>
<li>高斯核求和为1，用途：平滑</li>
<li>高斯一阶导核求和为0，用途：边缘提取</li>
</ul>
<p>可以发现LoG与DoG的函数图像近似，因此为了提高计算效率（当 $\sigma$ 变大，模板尺寸随之也变大，计算开销增大）常用DoG核来替代LoG核（SIFT就是这么干的）。</p>
<h4 id="2-3-中值滤波"><a href="#2-3-中值滤波" class="headerlink" title="2.3 中值滤波"></a>2.3 中值滤波</h4><p>中值滤波的窗口内没有权值，它的作用是把窗口内图像上所有像素值排序后取中值作为窗口中心点的像素值。</p>
<p><strong>对椒盐噪声有效，是非线性滤波</strong>。</p>
<h4 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h4><p>高斯滤波以及均值滤波都可以起到平滑图像的作用，高斯滤波可以视为有权的均值滤波，图像在平滑的时候不仅会把噪声，也会把图像边缘信息平滑掉（噪声、边缘都是高频成分，因为像素值通常会发生剧烈变化），两者都是低通滤波（low-pass filter）。</p>
<p>而中值滤波能够保留边缘信息，是高通滤波（high-pass filter）。</p>
<h3 id="3-其他滤波"><a href="#3-其他滤波" class="headerlink" title="3. 其他滤波"></a>3. 其他滤波</h3><p>双边滤波（bilateral filter）、导向滤波（guided filter）、拉普拉斯滤波等。</p>
<p>拉普拉斯滤波（和LoG区分一下）：</p>
<script type="math/tex; mode=display">
L(x,y) = \frac{\partial^2I}{\partial x^2} + \frac{\partial^2I}{\partial y^2}</script><p>近似图像上二阶梯度的离散卷积核（拉普拉斯算子）：</p>
<p><img src="https://homepages.inf.ed.ac.uk/rbf/HIPR2/figs/lapmask2.gif" alt=""></p>
<p>拉普拉斯滤波用途：边缘检测等。</p>
<p><img src="/images/Zly.jpg" alt=""></p>
<p>经过拉普拉斯卷积后：</p>
<p><img src="/images/edge.jpg" alt=""></p>
<p>手动实现效果与<code>cv2.Laplacian</code>效果相同</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kernel = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">-4</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]])</span><br><span class="line"><span class="comment"># no padding 卷积</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, img.shape[<span class="number">0</span>] - <span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, img.shape[<span class="number">1</span>] - <span class="number">2</span>):</span><br><span class="line">        img[i,j] = np.sum(kernel * img[i:i+<span class="number">3</span>, j:j+<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      
      
    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-机器视觉基础Lecture 3局部特征" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/15/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E5%9F%BA%E7%A1%80Lecture%203%E5%B1%80%E9%83%A8%E7%89%B9%E5%BE%81/"
    >机器视觉基础Lecture 3局部特征</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/10/15/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E5%9F%BA%E7%A1%80Lecture%203%E5%B1%80%E9%83%A8%E7%89%B9%E5%BE%81/" class="article-date">
  <time datetime="2020-10-15T12:20:42.841Z" itemprop="datePublished">2020-10-15</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E5%9F%BA%E7%A1%80/">机器视觉基础</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h3 id="Lecture-3-局部特征"><a href="#Lecture-3-局部特征" class="headerlink" title="Lecture 3 局部特征"></a>Lecture 3 局部特征</h3><h3 id="1-Harris角点检测"><a href="#1-Harris角点检测" class="headerlink" title="1. Harris角点检测"></a>1. Harris角点检测</h3><h4 id="1-1-特征点需要满足的性质"><a href="#1-1-特征点需要满足的性质" class="headerlink" title="1.1 特征点需要满足的性质"></a>1.1 特征点需要满足的性质</h4><p>可重复性/区分性/容易计算</p>
<p>为什么选角点？</p>
<p>一个窗口在图像上滑动，处于平坦（flat）区域时，窗口内的内容不会发生明显改变；处于边缘（edge）区域时，只有沿一个方向（竖直或水平）滑动会发生变化；而处于角点（corner）区域时，沿两个方向滑动窗口内容都会发生改变。</p>
<h4 id="1-2-角点"><a href="#1-2-角点" class="headerlink" title="1.2 角点"></a>1.2 角点</h4><script type="math/tex; mode=display">
E(u,v) = \sum_{x,y} w(x,y)[I(x + u, y + v) - I(x,y)]^2</script><p>说明：$x,y$的取值范围是窗口的范围；$w(x,y)$指权值函数，比如$Gaussian$函数，本质上取到一个加权的作用。$u,v$即平移的距离。$E(u,v)$表示窗口内容变化程度。</p>
<p>我们希望直接观察到$u,v$和$E(u,v)$之间的关系，而上式定义较麻烦不直观（还得通过$I(x,y)$），怎么直接建立关系呢？答案：二维泰勒展开！</p>
<script type="math/tex; mode=display">
E(u,v) \approx E(0,0) + [u,v]\begin{pmatrix}E_u(0,0)\\E_v(0,0)\end{pmatrix} +\frac{1}{2}[u,v]\begin{pmatrix}E_{uu}&E_{uv}\\E_{vu}&E_{vv}\end{pmatrix}\left [\begin{matrix}u\\v\end{matrix} \right]</script><script type="math/tex; mode=display">
E(0,0) = 0</script><script type="math/tex; mode=display">
E_{u}(u,v) = \sum_{x,y}2w(x,y)[I(x+u,y+v)-I(x,y)]I_x(x+u,y+v)</script><p>将(0,0)带入：得：$E_u(0,0) = 0$；同理可得$E_v(0,0)=0$；</p>
<p>为了表示方便，令：$I(x+u,y+v)$简写为$I$，$I_x(x+u,y+v)$简写为$I_x$等</p>
<script type="math/tex; mode=display">
E_{uu}(u,v) = \sum_{x,y}2w(x,y)I_xI_x+\sum_{x,y}2w(x,y)[I-I(x,y)]I_{xx}</script><script type="math/tex; mode=display">
E_{uv}(u,v) =\sum_{x,y}2w(x,y)I_yI_x+\sum_{x,y}2w(x,y)[I-I(x,y)]I_{xy}</script><p>带(0,0)有：</p>
<script type="math/tex; mode=display">
E_{uu}(0,0) = \sum_{x,y}2w(x,y)I_x(x,y)I_x(x,y)\\
E_{vv}(0,0) = \sum_{x,y}2w(x,y)I_y(x,y)I_y(x,y)\\
E_{uv}(0,0) =E_{vu}(0,0)= \sum_{x,y}2w(x,y)I_x(x,y)I_y(x,y)</script><p>即：</p>
<script type="math/tex; mode=display">
E(u,v) \approx [u,v]M\left[ \begin{matrix}u\\v\end{matrix} \right]</script><script type="math/tex; mode=display">
M_{2\times2} = \sum_{x,y}w(x,y)\left[\begin{matrix}I_x^2&I_xI_y\\I_xI_y&I_y^2\end{matrix}\right] = \left[\begin{matrix}\lambda_1&0\\0&\lambda_2\end{matrix}\right]</script><p>$I_x,I_y$即上一个Lecture讲过的图像上定义的梯度（同方向相邻两个像素的差值）。$M$被称为second moment matrix。它是一个对称正定矩阵，因此可以<strong>对角化</strong>为特征值组成的对角矩阵。</p>
<p>考虑：</p>
<script type="math/tex; mode=display">
E(u,v) = \lambda_1u^2 + \lambda_2v^2=C,C\in R</script><p>可知$E(u,v)$在几何上是一个椭圆。其轴分别为$1/\sqrt\lambda_1,1/\sqrt\lambda_2$。</p>
<p>$\lambda_1,\lambda_2$表示窗口内的$x,y$方向的图像梯度。当两个方向变化都很大时可能为角点。</p>
<script type="math/tex; mode=display">
R = \det(M) - \alpha *trace(M)^2 = \lambda_1\lambda_2-\alpha(\lambda_1+\lambda_2)^2</script><p><img src="/images/image-20201015212534161.png" alt="image-20201015212534161"></p>
<p>优点：对光照、亮度不敏感</p>
<p>缺点：对尺度（scale）变换敏感！</p>
<h3 id="2-Blob-Detection"><a href="#2-Blob-Detection" class="headerlink" title="2. Blob Detection"></a>2. Blob Detection</h3><h3 id="3-SIFT"><a href="#3-SIFT" class="headerlink" title="3. SIFT"></a>3. SIFT</h3><p>SIFT即尺度不变特征变换。光照、尺度、旋转、平移。</p>
<p>添加仿射自适应：更好的处理视角</p>
<p>观察dog图像和log图像发现他俩走势几乎一致，可以用dog来代替log提高计算效率</p>
<p>sift $4 \times 4 \times 8=128$ 维描述子，sift算法将邻域内像素划分为 $16×16$ 个子域，进一步将其划分为 $4×4$ 块（每个块又是由 $4×4$ 小域组成），具体见下，分别计算每个块内8个方向的梯度方向直方图。所以最终得到 $4×4×8=128$ 4×4×8=128 的描述子向量。</p>
<p><strong>梯度强度直方图</strong>：将$[0,2\pi]$划分为8份，也就是说$[0,\frac{\pi}{4}],[\frac{\pi}{4},\frac{\pi}{2}]，…,[\frac{7\pi}{4},2\pi]$。然后在这些小区域（16个像素）的范围内，根据每个像素点的梯度方向所在范围，将该像素点的梯度幅值加到对应的bin上，最后就形成了小区域一个梯度强度直方图（8个数字描述）。16个小区域的整体特征就可以用这个$4 \times 4 \times 8$的特征向量来描述。</p>
<p><img src="https://img-blog.csdn.net/20171025223351016?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hpeW9uZ3Jhb3c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>在小区域上（16个像素）统计梯度幅值直方图能更好的捕捉局部特征。</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      
      
    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-降维方法" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/13/%E9%99%8D%E7%BB%B4%E6%96%B9%E6%B3%95/"
    >降维方法</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/10/13/%E9%99%8D%E7%BB%B4%E6%96%B9%E6%B3%95/" class="article-date">
  <time datetime="2020-10-13T11:25:37.660Z" itemprop="datePublished">2020-10-13</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h2 id="降维方法"><a href="#降维方法" class="headerlink" title="降维方法"></a>降维方法</h2><h3 id="1-主成分分析"><a href="#1-主成分分析" class="headerlink" title="1. 主成分分析"></a>1. 主成分分析</h3><h4 id="1-1-算法分析"><a href="#1-1-算法分析" class="headerlink" title="1.1 算法分析"></a>1.1 算法分析</h4><p>已知样本$\pmb a_1,\pmb a_2,…,\pmb a_N,\pmb a_i \in \mathbb{R}^n$，则按列组成的矩阵:</p>
<script type="math/tex; mode=display">
A_{n \times m} = \begin{pmatrix}\pmb a_1,&\pmb a_2,...&,\pmb a_N\end{pmatrix}</script><p><strong>矩阵的弗罗贝尼乌斯范数</strong>：</p>
<script type="math/tex; mode=display">
||A||_2 = \sqrt {tr (A^TA)} = \sqrt{\sum_{i=1}^m\sum_{j=1}^na_{ij}^2}</script><p>$tr$代表矩阵的迹函数$trace$（主对角线元素求和，$A^TA$一定是个方阵）。</p>
<p>给定一组标准正交基$\pmb w_1,\pmb w_2,…,\pmb w_N,\pmb w_i \in \mathbb{R}^n$，$\mathbb{R}^n$中的某个向量$\pmb a$可以表示为：</p>
<script type="math/tex; mode=display">
\pmb a = \sum_{j = 1}^n <\pmb a,\pmb w_j>\pmb w_j</script><p>$&lt;,&gt;$表示向量的内积操作，可以看出$&lt;\pmb a,\pmb w_j&gt;$即$\pmb a$在空间中的坐标。现在我们考虑，是否可以将$\pmb a$表示在由$\pmb w_1,\pmb w_2,…,\pmb w_m,m \mathbb{&lt;&lt;} n$，生成的子空间$\mathbb{R}^m$中，使得$&lt;\pmb a,\pmb w_{m+1}&gt;=0,…,&lt;\pmb a, \pmb w_n&gt; = 0$ ?也就是说只需要前$m$个基就可以表示$\pmb a$。</p>
<p><strong>降维准则：</strong> 找到一组基，使得数据在这组基表示下，$m+1,…n$维的坐标都是0。</p>
<p><strong>注意：</strong>$\pmb w_i$仍然是包含$n$个分量的向量，$m$个包含$n$个元素基向量构成了$n$维空间的一个$m$维子空间（空间的维数等于基向量个数）。</p>
<p>这就可以将问题转化为一个优化问题：</p>
<script type="math/tex; mode=display">
\min_{\pmb w_1,\pmb w_2,...,\pmb w_m} = \sum_{i=1}^N ||\pmb a_i - \sum_{j=1}^m<\pmb a_i,\pmb w_j>\pmb w_j||_2^2\\
s.t.<\pmb w_i,\pmb w_j> = \delta_{ij},i=j,\delta_{ij}=1;i\not=j,\delta_{ij}=0</script><p>写为矩阵形式即：</p>
<script type="math/tex; mode=display">
\arg \min_{\pmb w_1,\pmb w_2,...,\pmb w_m} = ||A-WW^TA||_2^2\\
s.t. W^TW = I_{m \times m}</script><p>其中，$A$为数据的特征矩阵，$W_{n \times m}$为前$m$个正交基按列组成的矩阵，它是半正交的。</p>
<p><strong>tips：</strong>因为有$m$个基向量，两两相乘，最后矩阵是一个$m \times m$的单位阵。</p>
<script type="math/tex; mode=display">
||A-WW^TA||_2^2 = tr\{(A-WW^TA)^T(A-WW^TA)\} = tr(A^TA) - tr(A^TWW^TA)</script><p>由于$tr(A^TA)$这一项与优化目标无关，因此目标函数变为：</p>
<script type="math/tex; mode=display">
\arg\min_{W}-tr(A^TWW^TA) = -tr\{(W^TA)^T(W^TA)\} = -||W^TA||^2_2\\s.t: W^TW = I</script><p>求出最忧$W$后，降维数据：</p>
<script type="math/tex; mode=display">
Y_{m \times N} = W_{m \times n}^TX_{n\times N}</script><p>以上推导过程从<strong>基向量</strong>、最优化角度解释了主成分分析算法。</p>
<p><strong>注意：</strong>主成分分析是无监督、线性的降维方法。线性判别分析是有监督的线性降维方法。</p>
<p><strong>说明：</strong>降维后的空间与原空间没有对应关系，主成分是原始维度的线性组合得到。</p>
<h4 id="1-2-算法描述"><a href="#1-2-算法描述" class="headerlink" title="1.2 算法描述"></a>1.2 算法描述</h4><p><img src="https://img-blog.csdnimg.cn/20191109182949751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05FRlVaWUo=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20191109191048929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05FRlVaWUo=,size_16,color_FFFFFF,t_70" alt="img"></p>
<h4 id="1-3-sklearn中的PCA"><a href="#1-3-sklearn中的PCA" class="headerlink" title="1.3 sklearn中的PCA"></a>1.3 sklearn中的PCA</h4><p>PCA位于$sklearn.decomposition$包下。</p>
<p>注意“explained_variance_ratio_”这个指标，表示了原始数据在不同主成分上的方差占比（保留了多少原始数据的方差信息）。</p>
<p>扩展的PCA：Incremental PCA，当数据量特别大无法一次性加载至内存进行奇异值分解时，可以将数据划分为多个mini-batch，然后进行降维。</p>
<p>Kernel PCA：非线性降维。</p>
<p><strong>Question: Can PCA  be used to reduce the dimensionality of a highly nonlinear dataset？</strong></p>
<p><strong>Answer</strong>: PCA can be used to significantly reduce the dimensionality of most datasets, even if they are highly nonlinear, because it can at least get rid of useless dimensions. However, if there are no useless dimensions — for example, the Swiss roll — then reducing dimensionality with PCA will lose too much information. You want to unroll the Swiss roll, not squash it</p>
<h3 id="2-非负矩阵分解"><a href="#2-非负矩阵分解" class="headerlink" title="2. 非负矩阵分解"></a>2. 非负矩阵分解</h3><p>非负矩阵分解：Nonnegative Matrix Factorization</p>
<script type="math/tex; mode=display">
\min ||X - WH||^2\\
s.t.W>=0,H>=0</script><h3 id="3-局部线性嵌入"><a href="#3-局部线性嵌入" class="headerlink" title="3. 局部线性嵌入"></a>3. 局部线性嵌入</h3><p>局部线性嵌入：Locally Linear Embedding（LLE），<strong>属于非线性降维</strong></p>
<p>参考： <a href="https://www.cnblogs.com/pinard/p/6266408.html" target="_blank" rel="noopener">https://www.cnblogs.com/pinard/p/6266408.html</a></p>
<p>流形学习（manifold learning）第一次听说”manifold”是在学习生成对抗网络的时候看到的。</p>
<p>推导过程中需要注意的地方：</p>
<p>下图中由$(1)\rightarrow(2)$过程中，因为$\sum_{j\in Q(i)}w_{ij} = 1$，所以$x_i = x_i \times 1 = \sum_{j\in Q(i)}w_{ij}x_i$。</p>
<p><img src="E:\hexo\themes\ayer\source\images\image-20201013195547190.png" alt="image-20201013195547190"></p>
<p><strong>算法描述</strong>：</p>
<h3 id="4-线性判别分析"><a href="#4-线性判别分析" class="headerlink" title="4. 线性判别分析"></a>4. 线性判别分析</h3><p>线性判别分析：Linear Discriminate Analysis（LDA）</p>
<p>降维原则：<strong>投影后</strong>最小化类内方差，最大化类间方差。属于线性、有监督的降维方法。</p>
<p>参考：<a href="https://www.jianshu.com/p/13ec606fdd5f" target="_blank" rel="noopener">https://www.jianshu.com/p/13ec606fdd5f</a> （二分类为例）</p>
<p>样本集：$\{(\pmb x_1,y_1),(\pmb x_2,y_2),…,(\pmb x_N,y_N)\},\pmb x_i \in \mathbb{R}^n$形成的样本矩阵$X_{n \times N}$，降维后数据$\pmb y$是一个$N \times 1$的向量</p>
<p>各个类的均值向量：</p>
<script type="math/tex; mode=display">
\pmb \mu_0 = \frac{1}{N_0}\sum_{\pmb x\in {0}}\pmb x\\
\pmb \mu_1 = \frac{1}{N_1}\sum_{\pmb x\in {1}}\pmb x</script><p>降维后的均值向量：</p>
<script type="math/tex; mode=display">
\tilde {\pmb \mu_0} = \frac{1}{N_0}\sum_{\pmb y\in 0}\pmb y =\frac{1}{N_0}\sum_{\pmb y\in 0}\pmb w^T\pmb x = \pmb w^T\pmb \mu_0</script><p>$\pmb w_{n \times 1}$就是我们要求的降维变换，同理：</p>
<script type="math/tex; mode=display">
\tilde {\pmb \mu_1} = \pmb w^T\pmb \mu_1</script><p>类内方差：</p>
<script type="math/tex; mode=display">
\tilde s_i^2 = \sum (\pmb y - \tilde{\pmb {\mu_i})^2}) = \sum (\pmb w^T\pmb x - \pmb w^T\pmb \mu_i)^2</script><p>即：</p>
<script type="math/tex; mode=display">
\tilde s_i^2 = \sum_{\pmb x\in i}[\pmb w^T(\pmb x - \pmb \mu_i)]^2 = \sum_{\pmb x\in i} [\pmb w^T(\pmb x-\pmb \mu_i)]^T[\pmb w^T(\pmb x-\pmb \mu_i)] = \sum_{\pmb x\in i} (\pmb x -\pmb \mu_i)^T\pmb w\pmb w^T(\pmb x-\pmb \mu_i)\\=\sum_{\pmb x\in i}\pmb w^T(\pmb x - \pmb \mu_i)(\pmb x - \pmb \mu_i)^T\pmb w</script><p><strong>说明：</strong>因为$(\pmb x -\pmb \mu_i)^T\pmb w$与$\pmb w^T(\pmb x-\pmb \mu_i)$ 结果分别是两个实数，可以交换。</p>
<p>令</p>
<script type="math/tex; mode=display">
\sum_{\pmb x\in i}(\pmb x - \pmb \mu_i)(\pmb x - \pmb \mu_i)^T = S_i</script><p>根据投影后类内方差小（$\tilde s_1^2 + \tilde s_0^2$ 两个都要小总体才能小），类间方差大（$||\pmb \mu_1 - \pmb \mu_2||^2$）。可以写出目标函数：</p>
<script type="math/tex; mode=display">
\max J(\pmb w) = \max \frac{||\pmb \mu_1 - \pmb \mu_2||^2}{\tilde s_1^2 + \tilde s_0^2}</script><p>并且根据上面的式子有：</p>
<script type="math/tex; mode=display">
\tilde s_1^2 + \tilde s_0^2 = \pmb w^T(S_0 + S_1)\pmb w =\pmb w^TS_W\pmb w = \tilde S_w</script><p>$S_W$：类内方差（with class）维度：$n \times n$</p>
<p>对于分子，我们有：</p>
<script type="math/tex; mode=display">
||\pmb \mu_1 - \pmb \mu_2||^2 = (\pmb w^T\pmb \mu_1 - \pmb w^T\pmb \mu_2)^2=\pmb w^T(\pmb \mu_1-\pmb \mu_2)(\pmb \mu_1-\pmb \mu_2)^T\pmb w</script><p>令：</p>
<script type="math/tex; mode=display">
(\pmb \mu_1-\pmb \mu_2)(\pmb \mu_1-\pmb \mu_2)^T = S_B</script><p>$S_B$：类间方差（between class）维度：$n \times n$</p>
<p>所以：</p>
<script type="math/tex; mode=display">
||\pmb \mu_1 - \pmb \mu_2||^2  = \pmb w^TS_B\pmb w = \tilde S_B</script><p>目标函数变为：</p>
<script type="math/tex; mode=display">
\max_{\pmb w} \frac{\pmb w^TS_B\pmb w}{\pmb w^TS_W\pmb w }</script><p>对$J(\pmb w)$对$\pmb w$求导并令其等于0即：</p>
<script type="math/tex; mode=display">
2S_B\pmb w(\pmb w^TS_W\pmb w)-2S_W\pmb w(\pmb w^TS_B\pmb w) = 0</script><p>注意：$\pmb w^TS_W\pmb w,\pmb w^TS_B\pmb w$结果都是实数，因此等式两边同除$\pmb w^TS_B\pmb w$可得：</p>
<script type="math/tex; mode=display">
S_W\pmb w =\frac{\pmb w^TS_W\pmb w}{\pmb w^TS_B\pmb w} S_B\pmb w</script><script type="math/tex; mode=display">
\pmb w = CS_W^{-1}S_B\pmb w</script><p>注意到：</p>
<script type="math/tex; mode=display">
S_B\pmb w =(\pmb \mu_1-\pmb \mu_2)(\pmb \mu_1-\pmb \mu_2)^T\pmb w</script><p>且$(\pmb \mu_1-\pmb \mu_2)^T\pmb w$结果是一个实数，C也是实数，我们要求的最关键的是$\pmb w$的方向，这些实数并不会改变方向，因此</p>
<script type="math/tex; mode=display">
\pmb w^* = S_W^{-1}(\pmb \mu_1 - \pmb \mu_2)</script><h3 id="5-多维尺度分析"><a href="#5-多维尺度分析" class="headerlink" title="5. 多维尺度分析"></a>5. 多维尺度分析</h3><p>Multidimensional Scaling</p>
<p>基本思想：尽量满足原始高维度空间中样本之间的距离在低维空间中得以保持。</p>
<p>“metric” or “non-metric”</p>
<p>给定样本$(\pmb x_1,\pmb x_2,…,\pmb x_N),\pmb x_i \in \mathbb{R}^n$构成的样本矩阵$X_{n \times N}$，降维后的样本矩阵$Y_{m \times N}$。根据多维尺度分析的基本思想：保持样本间距离不变，原始样本间距离$d_{ij}=||\pmb x_i - \pmb x_j||$构成的矩阵$D_{N \times N}$。</p>
<p>可知$X^TX = -\frac{1}{2}HD_xH, Y^TY = \frac{1}{2}HD_yH$，我们想让$D_x=D_y$，等价的可以通过以下目标函数来求得：</p>
<p>目标函数：</p>
<script type="math/tex; mode=display">
\min ||X^TX - Y^TY||^2</script><p>特征值分解：</p>
<script type="math/tex; mode=display">
X^TX = U^T\Lambda U</script><p>那么降维后的数据$Y$：</p>
<script type="math/tex; mode=display">
Y = \Lambda^{1/2}U</script><h3 id="6-典型关联分析"><a href="#6-典型关联分析" class="headerlink" title="6. 典型关联分析"></a>6. 典型关联分析</h3><p>Canonical correlation analysis</p>
<p>参考：<a href="https://www.cnblogs.com/pinard/articles/6288716.html" target="_blank" rel="noopener">https://www.cnblogs.com/pinard/articles/6288716.html</a></p>
<p>具体思想：相关系数 $\rho$ 可以分析两组一维数据$X,Y$的线性相关性，$\rho$取值越接近1则$X,Y$的线性相关性越高。虽然相关系数可以很好的帮我们分析一维数据的相关性，但是对于高维数据就不能直接使用了。比如$X$是2维数据，$Y$是三维数据，就不能用相关系数进行分析。那么有没有变通的方法呢？典型关联分析给出了思路，具体就是将多维的$X,Y$分别用线性变换为1维的$X^\prime,Y^\prime$，然后使用相关系数分析1维$X^\prime,Y^\prime$的相关性。问题又来了，如何把$X,Y$变换为$X^\prime，Y^\prime$呢？也就是说降维的准则是什么？<strong>典型关联分析使用的准则是变换到1维后，$X^\prime,Y^\prime$的相关系数最大。</strong></p>
<p>亦即：</p>
<script type="math/tex; mode=display">
arg \max_{\pmb a,\pmb b} ||X^T\pmb a - Y^T\pmb b||^2</script><p><strong>算法描述</strong>：</p>
<h3 id="7-字典学习"><a href="#7-字典学习" class="headerlink" title="7. 字典学习"></a>7. 字典学习</h3><p>参考：<a href="https://zhuanlan.zhihu.com/p/46085035" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46085035</a></p>
<p><strong>基本思想：</strong></p>
<p>在人类发展的近几千年历史中，文字对人类文明的推动起着举足轻重的作用。人类用文字记述了千年的历史，用文字留下了各种思想火花，用文字抒发了各种各样的情感等等。但是这一切的内容，只需要一本字典就能表述完。因为人在这环节中的功能，无非就是使用字典当中的字词进行了适当的排列了而已。</p>
<p>基于这种思想，先前的大佬提出了字典学习——Dictionary Learning。</p>
<p>字典学习的目标，就是提取事物<strong>最本质的特征（类似于字典当中的字或词语）。</strong>如果我们能都获取这本包括<strong>最本质的特征</strong>的字典，那我们就掌握了这个事物的最本质的内涵。换言之，字典学习将我们的到的对于物体的信息降维，减少了该物体一些无关紧要信息对我们定义这个物体的干扰。</p>
<p><strong>模型建立：</strong></p>
<script type="math/tex; mode=display">
\pmb x = \sum_{i=1}^m \lambda_i\pmb w_i</script><p>$\lambda_i$称为表示系数，要求尽可能稀疏；$\pmb w_i$被称为”字典“。</p>
<p>问题是如何找到表示系数与字典？可转化为如下优化问题：</p>
<script type="math/tex; mode=display">
\min \sum_{i=1}^N||\pmb x_i - \sum_{j=1}^m y_{ij}\pmb w_j||^2 \\
s.t. ||\pmb y_i|| <= C</script><p>其中：$y$即为表示系数，约束条件对应要求表示系数尽可能稀疏。$m &gt;&gt;N$。</p>
<p>写成矩阵形式（有点类似非负矩阵分解形式，W是基，Y是系数）：</p>
<script type="math/tex; mode=display">
\min ||X - WY||^2\\
s.t.||Y|| <= C</script><p>由于上述优化问题含有两个优化变量，可采用坐标优化方法，即先固定系数$y$，求出最优的$\pmb w$；然后在求出系数。</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      
      
    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-机器视觉基础Lecture 2" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/08/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E5%9F%BA%E7%A1%80Lecture%202/"
    >机器视觉基础Lecture 2</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/10/08/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E5%9F%BA%E7%A1%80Lecture%202/" class="article-date">
  <time datetime="2020-10-08T09:28:38.672Z" itemprop="datePublished">2020-10-08</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E5%9F%BA%E7%A1%80/">机器视觉基础</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h2 id="机器视觉基础-Lecture-2"><a href="#机器视觉基础-Lecture-2" class="headerlink" title="机器视觉基础 Lecture 2"></a>机器视觉基础 Lecture 2</h2><h3 id="0-数字图像基础"><a href="#0-数字图像基础" class="headerlink" title="0. 数字图像基础"></a>0. 数字图像基础</h3><h4 id="0-1-相机的成像原理"><a href="#0-1-相机的成像原理" class="headerlink" title="0.1 相机的成像原理"></a>0.1 相机的成像原理</h4><p>数码相机使用了感光器件（CMOS/CCD），将光信号转变为电信号（模拟信号），再经模/数转换后形成数字信号，在经过一系列处理形成特定的图像文件格式存储于存储卡上。</p>
<h4 id="0-2-图像的采样和量化"><a href="#0-2-图像的采样和量化" class="headerlink" title="0.2 图像的采样和量化"></a>0.2 图像的采样和量化</h4><p>采样，就是把一幅连续图像在空间上分割成M×N个网格，每个网格用一亮度值来表示。一般来说，采样间隔越大，所得图像像素数越少，空间分辨率低，质量差，严重时出现马赛克效应；采样间隔越小，所得图像像素数越多，空间分辨率高，图像质量好，但数据量大。</p>
<p>量化，就是把采样点上对应的亮度连续变化区间转换为单个特定数码的过程。量化后，图像就被表示成一个整数矩阵。每个像素具有两个属性：位置和灰度。位置由行、列表示。灰度表示该像素位置上亮暗程度的整数。此数字矩阵M×N就作为计算机处理的对象了。灰度级一般为0－255（8bit量化）。</p>
<h4 id="0-3-数字图像和信号处理"><a href="#0-3-数字图像和信号处理" class="headerlink" title="0.3 数字图像和信号处理"></a>0.3 数字图像和信号处理</h4><p>图片也是一种特殊的信号。</p>
<h4 id="0-4-颜色空间"><a href="#0-4-颜色空间" class="headerlink" title="0.4 颜色空间"></a>0.4 颜色空间</h4><p>RGB、HSV、Lab、CIE等等。</p>
<h4 id="0-5-图像的直方图"><a href="#0-5-图像的直方图" class="headerlink" title="0.5 图像的直方图"></a>0.5 图像的直方图</h4><h3 id="1-图像滤波"><a href="#1-图像滤波" class="headerlink" title="1. 图像滤波"></a>1. 图像滤波</h3><h4 id="1-1-滤波器"><a href="#1-1-滤波器" class="headerlink" title="1.1 滤波器"></a>1.1 滤波器</h4><p>滤波器英文filter/mask/kernel。可分为线性滤波器和非线性滤波器，高通滤波器（只允许图像中高频成分通过，换句话说滤掉低频成分）和低通滤波器。</p>
<p>均值滤波（低通滤波）、高斯滤波（低通滤波，重要的两个参数：kernel size和方差$\sigma^2$）、中值滤波（高通滤波，非线性，会锐化sharpen图片，比如增强边缘）、拉普拉斯滤波。</p>
<p>窗口滑动时如何处理边界问题：full、same、valid。</p>
<p>低通滤波会不同程度的平滑图片。</p>
<p>高频成分：图像中的边缘、噪声。</p>
<p>本质上：采用一个kernel然后在图像上滑动加权求和，因此<strong>kernel的大小和权重</strong>很重要。</p>
<h4 id="1-2-梯度与边缘检测"><a href="#1-2-梯度与边缘检测" class="headerlink" title="1.2 梯度与边缘检测"></a>1.2 梯度与边缘检测</h4><p>由于图像边缘处像素值通常变化剧烈，由此形成像素值上的不连续，因此可以通过求梯度来检测图像中的边缘。将图像看作一个二维离散函数$f(x,y)$，图像梯度其实就是这个二维离散函数的求导。</p>
<p>正常微分定义：</p>
<script type="math/tex; mode=display">
\frac{\partial f(x,y)}{\partial x} = \lim_{\epsilon \rightarrow 0} \frac{f(x + \epsilon,y) - f(x,y)}{\epsilon},\frac{\partial f(x,y)}{\partial y} = \lim_{\epsilon \rightarrow 0} \frac{f(x,y  + \epsilon) - f(x,y)}{\epsilon}</script><p>但是图像是按照像素来离散的，最小也就1像素，因此普通的微分形式变成了：</p>
<script type="math/tex; mode=display">
\frac{\partial f(x,y)}{\partial x} = f(x + 1,y) - f(x,y),\frac{\partial f(x,y)}{\partial y} =f(x,y+1) - f(x,y)</script><p><strong>可以看出，图像的梯度本质上相当于2个相邻像素之间的差值。</strong></p>
<p>因此定义梯度算子（kernel）：水平$[-1,1]$ 右边像素 - 左边像素；垂直：$[-1,1]^T$下边像素-上边像素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">"126007.jpg"</span>,<span class="number">0</span>)</span><br><span class="line">img = img.astype(<span class="string">'float'</span>)</span><br><span class="line"></span><br><span class="line">row = img.shape[<span class="number">0</span>]</span><br><span class="line">col = img.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">gradient_x = np.zeros((row, col))</span><br><span class="line">gradient_y = np.zeros((row, col))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(row - <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(col - <span class="number">1</span>):</span><br><span class="line">        gy = abs(img[i + <span class="number">1</span>, j] - img[i, j]) <span class="comment">#下边像素-上边像素</span></span><br><span class="line">        gx = abs(img[i, j + <span class="number">1</span>] - img[i, j]) <span class="comment">#右边像素-左边像素</span></span><br><span class="line">        gradient_x[i, j] = gx</span><br><span class="line">        gradient_y[i, j] = gy</span><br><span class="line">gradient_x = gradient_x.astype(<span class="string">'uint8'</span>)</span><br><span class="line">gradient_y = gradient_y.astype(<span class="string">'uint8'</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">"gradient_x"</span>, gradient_x)</span><br><span class="line">cv2.imshow(<span class="string">"gradient_y"</span>, gradient_y)</span><br><span class="line">cv2.waitKey()</span><br></pre></td></tr></table></figure>
<p><img src="/images/grad_x.jpg" alt=""></p>
<p>水平方向梯度</p>
<p><img src="/images/grad_y.jpg" alt=""></p>
<p>垂直方向梯度</p>
<p>水平方向求偏导：$\frac{\partial f}{\partial x}$，竖直方向求偏导：$\frac{\partial f}{\partial y}$，图像梯度：$\nabla f = [\frac{\partial f}{\partial x},\frac{\partial f}{\partial y}]$。</p>
<p>水平：$\nabla f = [\frac{\partial f}{\partial x},0]$，垂直：$\nabla f = [0,\frac{\partial f}{\partial y}]$</p>
<p>梯度方向：$\theta = \tan^{-1}(\frac{\partial f}{\partial y}/\frac{\partial f}{\partial x})$</p>
<p><strong>梯度幅值（gradient magnitude）</strong>：$||\nabla f||=\sqrt {(\frac{\partial f}{\partial x})^2+(\frac{\partial f}{\partial y})^2}$</p>
<p>注意：求梯度之前先做平滑，否则噪声也是高频，求梯度后无法分辨哪里是噪声哪里是边缘。如下图。</p>
<p><img src="/images/image-20201008191252006.png" alt="image-20201008191252006" style="zoom:67%;" /></p>
<p><img src="/images/image-20201008191306409.png" alt="image-20201008191306409" style="zoom:67%;" /></p>
<p>首先平滑图像后：</p>
<p><img src="/images/image-20201008191404392.png" alt="image-20201008191404392" style="zoom:67%;" /></p>
<p>$f:signal;g:kernel$</p>
<script type="math/tex; mode=display">
\frac{d}{dx}(f*g) = f*\frac{d}{dx}g</script><p>用高斯一阶导去和信号做卷积，干了两件事：一是平滑信号，二是求导。相当于先用高斯滤波平滑再求导。 同理高斯二阶导，用高斯二阶导去和信号卷积。</p>
<ul>
<li>高斯核求和为1，用途：平滑</li>
<li>高斯一阶导核求和为0，用途：边缘提取</li>
</ul>
<p><strong>Canny边缘检测</strong></p>
<p>代码参见同专题下另一篇博客。</p>
<h4 id="1-3-模板匹配"><a href="#1-3-模板匹配" class="headerlink" title="1.3 模板匹配"></a>1.3 模板匹配</h4><p>滤波器的一个应用。</p>
<h3 id="2-图像的特征"><a href="#2-图像的特征" class="headerlink" title="2. 图像的特征"></a>2. 图像的特征</h3><h4 id="图像纹理texture"><a href="#图像纹理texture" class="headerlink" title="图像纹理texture"></a>图像纹理texture</h4><p>纹理分类</p>
<p>纹理是由重复的局部<strong>模式</strong>（local pattern）构成的。</p>
<p>如何描述纹理？最简单的就是用图像上x方向、y方向的梯度这两个维度来描述某一window的纹理特征；但这显然是不够的，因此可以使用多个不同的卷积核去与图像卷积，若采用 $d$ 个不同的卷积核，则特征向量的维度就是 $d$ 维。（可以看到卷积神经网络的前身，这里的卷积核是我们设计好的，神经网络中的核是学习到的）。下图中，使用48个卷积核，卷积过后可以得到48维的特征向量。（其实就是48张feature map）</p>
<p><img src="/images/kernels.png" alt="image-20201029180022688" style="zoom:80%;" /></p>
<p>不同的核卷积过后会得到不同的response。</p>
<p><img src="/images/texture-response.png" alt="image-20201029180511558"></p>
<p>注意：方块对应的颜色代表数值强弱，白色说明数值最大，黑色说明数值最小，这个数值是怎么来的呢？其实就是用一个模板卷积过后得到一幅图像，将卷积后图像中的数值全部相加再取<strong>平均</strong>得到一个数值（mean response）。上图中一幅图像就可以表示成7维的向量。</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      
      
    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-多元高斯及其极大似然估计" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/06/%E5%A4%9A%E5%85%83%E9%AB%98%E6%96%AF%E5%8F%8A%E5%85%B6%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/"
    >多元高斯及其极大似然估计</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/10/06/%E5%A4%9A%E5%85%83%E9%AB%98%E6%96%AF%E5%8F%8A%E5%85%B6%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/" class="article-date">
  <time datetime="2020-10-06T07:54:18.217Z" itemprop="datePublished">2020-10-06</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h2 id="多元高斯及其极大似然估计"><a href="#多元高斯及其极大似然估计" class="headerlink" title="多元高斯及其极大似然估计"></a>多元高斯及其极大似然估计</h2><p>参考：<a href="https://blog.csdn.net/Joyliness/article/details/80097491" target="_blank" rel="noopener">https://blog.csdn.net/Joyliness/article/details/80097491</a></p>
<h3 id="1-独立多元高斯的概率密度函数"><a href="#1-独立多元高斯的概率密度函数" class="headerlink" title="1. 独立多元高斯的概率密度函数"></a>1. 独立多元高斯的概率密度函数</h3><p>$n$个独立的随机变量$(x_1,x_2,…x_n)$的联合密度函数为</p>
<script type="math/tex; mode=display">
f_{\mu,\Sigma}(\pmb x)=\frac{1}{\sqrt{(2\pi)^n\det\Sigma}}e^{-\frac{1}{2}(\pmb x - \pmb \mu)^T\Sigma^{-1}(\pmb x - \pmb \mu)}</script><p>就是多元高斯分布（Multivariate Normal Distribution，MVN）。其中，$\pmb \mu$是各个随机变量的期望值所组成的向量，$\Sigma$是随机变量间的协方差矩阵，是$n \times n$的正定矩阵。</p>
<h3 id="2-多元高斯的极大似然估计"><a href="#2-多元高斯的极大似然估计" class="headerlink" title="2. 多元高斯的极大似然估计"></a>2. 多元高斯的极大似然估计</h3><p>对于$N$个满足多元高斯分布的独立样本集：$\{\pmb x_1,\pmb x_2,..,\pmb x_N\},\pmb x \in  \mathbb{R}^n$，似然函数为：</p>
<script type="math/tex; mode=display">
\prod_{i=1}^Nf_{\mu,\Sigma}(\pmb x_i) = (2\pi)^{-\frac{Nn}{2}}|\Sigma|^{-\frac{N}{2}}e^{-\frac{1}{2}\sum_{i=1}^N(\pmb x_i - \pmb \mu)^T\Sigma^{-1}(\pmb x_i - \pmb \mu)}</script><p>取对数：</p>
<script type="math/tex; mode=display">
\ln L(\pmb \mu,\Sigma) =\ln\prod_{i=1}^Nf_{\mu,\Sigma}(\pmb x_i) =-\frac{Nn}{2}\ln2\pi -\frac{N}{2}\ln |\Sigma| - \sum_{i=1}^N(\pmb x_i - \pmb \mu)^T\Sigma^{-1}(\pmb x_i - \pmb \mu)\\
=C - \frac{N}{2}\ln |\Sigma| - \frac{1}{2}\sum_{i=1}^N(\pmb x_i - \pmb \mu)^T\Sigma^{-1}(\pmb x_i - \pmb \mu)</script><p>其中$C = -\frac{Nn}{2}\ln2\pi$是一个与参数$\pmb \mu,\Sigma$ 无关的常数，因此：</p>
<script type="math/tex; mode=display">
arg\max_{\pmb \mu,\Sigma}\ln\prod_{i=1}^Nf_{\mu,\Sigma}(\pmb x_i)</script><ul>
<li>$\ln L(\pmb \mu,\Sigma)$对$\pmb \mu$求偏导（标量对向量求偏导）</li>
</ul>
<p>先将$\sum_{i=1}^N(\pmb x_i - \pmb \mu)^T\Sigma^{-1}(\pmb x_i - \pmb \mu)$展开，得到：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^N\pmb x_i^T\Sigma^{-1}\pmb x_i - 2\sum_{i=1}^N\pmb x^T\Sigma^{-1}\pmb \mu + N\pmb \mu^T\Sigma^{-1}\pmb \mu</script><p>后两项对$\pmb \mu$求偏导得到：</p>
<script type="math/tex; mode=display">
-2\sum_{i=1}^N\Sigma^{-1}\pmb x_i + 2N\Sigma^{-1}\pmb \mu</script><p>因此：</p>
<script type="math/tex; mode=display">
\frac{\partial \ln L(\pmb \mu,\Sigma)}{\partial \pmb \mu} = 2\sum_{i=1}^N\Sigma^{-1}\pmb x_i - 2N\Sigma^{-1}\pmb \mu = 0</script><p>求得：</p>
<script type="math/tex; mode=display">
\bar{\pmb \mu} = \frac{1}{N}\sum_{i=1}^N \pmb x_i</script><ul>
<li>$\ln L(\pmb \mu, \Sigma)$对$\Sigma$求偏导（标量对矩阵求偏导）</li>
</ul>
<p>tips：$\frac{\partial \det(X)}{\partial X } = \det (X)tr(X^{-1})$</p>
<script type="math/tex; mode=display">
\frac{\partial -\frac{N}{2}\ln \det(\Sigma)}{\partial \Sigma} = -\frac{N}{2}tr(X^{-1})</script><script type="math/tex; mode=display">
\frac{\partial \ln L(\pmb \mu, \Sigma)}{\partial \Sigma} = 0</script><p>解得：</p>
<script type="math/tex; mode=display">
\bar \Sigma = \frac{1}{N} \sum_{i=1}^N(\pmb x_i - \bar{\pmb \mu})(\pmb x_i - \bar{\pmb \mu})^T</script>
      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      
      
    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-Transformer模型介绍" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/03/Transformer%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D/"
    >Transformer模型介绍</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/10/03/Transformer%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time datetime="2020-10-03T06:58:05.171Z" itemprop="datePublished">2020-10-03</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h2 id="Transformer模型介绍"><a href="#Transformer模型介绍" class="headerlink" title="Transformer模型介绍"></a>Transformer模型介绍</h2><p>文献：Vaswani A,  Shazeer N,  Parmar N,  et al.  Attention is all you need[C]. Advances in neural information processing systems. 2017: 5998-6008.</p>
<p>详解：<a href="http://nlp.seas.harvard.edu/2018/04/03/attention.html" target="_blank" rel="noopener">http://nlp.seas.harvard.edu/2018/04/03/attention.html</a>  The Annotated Transformer.</p>
<p>视频：<a href="https://www.youtube.com/watch?v=ugWDIIOHtPA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=ugWDIIOHtPA</a>  李宏毅：Transformer</p>
<h3 id="1-encoder-decoder"><a href="#1-encoder-decoder" class="headerlink" title="1. encoder-decoder"></a>1. encoder-decoder</h3><h3 id="2-self-attention"><a href="#2-self-attention" class="headerlink" title="2. self attention"></a>2. self attention</h3><h3 id="3-multi-head-attention"><a href="#3-multi-head-attention" class="headerlink" title="3. multi head attention"></a>3. multi head attention</h3><h3 id="4-attention和self-attention区别"><a href="#4-attention和self-attention区别" class="headerlink" title="4. attention和self-attention区别"></a>4. attention和self-attention区别</h3>
      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      
      
    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-贝叶斯垃圾邮件分类器" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/29/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%9E%83%E5%9C%BE%E9%82%AE%E4%BB%B6%E5%88%86%E7%B1%BB%E5%99%A8/"
    >贝叶斯垃圾邮件分类器</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/09/29/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%9E%83%E5%9C%BE%E9%82%AE%E4%BB%B6%E5%88%86%E7%B1%BB%E5%99%A8/" class="article-date">
  <time datetime="2020-09-29T03:06:11.061Z" itemprop="datePublished">2020-09-29</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h2 id="贝叶斯垃圾邮件分类器"><a href="#贝叶斯垃圾邮件分类器" class="headerlink" title="贝叶斯垃圾邮件分类器"></a>贝叶斯垃圾邮件分类器</h2><p>利用朴素贝叶斯算法，在给定训练数据上，训练一个垃圾分类器。有关朴素贝叶斯的基本思想，可以参见另一篇博客：<a href="https://zyj-nova.github.io/2020/02/09/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%EF%BC%88Naive%20Bayes%EF%BC%89/" target="_blank" rel="noopener">https://zyj-nova.github.io/2020/02/09/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%EF%BC%88Naive%20Bayes%EF%BC%89/</a></p>
<h3 id="0-数据集获取"><a href="#0-数据集获取" class="headerlink" title="0 数据集获取"></a>0 数据集获取</h3><p>链接：<a href="https://pan.baidu.com/s/1P3Jg67nerg63GVbCkc1YJg" target="_blank" rel="noopener">https://pan.baidu.com/s/1P3Jg67nerg63GVbCkc1YJg</a> ，提取码：576u 。</p>
<p>数据集为英文语料，分为训练集和测试集。训练集包含351封垃圾邮件（文件名标有“spmsg”）、351封正常邮件；测试集包含130封正常邮件和130封垃圾邮件。</p>
<h3 id="1-特征提取"><a href="#1-特征提取" class="headerlink" title="1 特征提取"></a>1 特征提取</h3><p>由于每一封邮件都不是数值型的特征，因此我们需要把他们编码。首先需要构建一个字典，统计所有邮件中单词出现的频率，同时删除字典中的非字母字符、长度为1的字符，之后取前3000个出现频率最高的作为最终的字典。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">n_dim = <span class="number">3000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_Dictionary</span><span class="params">(train_dir)</span>:</span></span><br><span class="line">    emails = [os.path.join(train_dir, f) <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(train_dir)]</span><br><span class="line">    all_words = []</span><br><span class="line">    <span class="keyword">for</span> mail <span class="keyword">in</span> emails:</span><br><span class="line">        <span class="keyword">with</span> open(mail) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="comment"># 遍历每一行</span></span><br><span class="line">            <span class="keyword">for</span> i,line <span class="keyword">in</span> enumerate(f):</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">2</span>):</span><br><span class="line">                    <span class="comment">#正文开始</span></span><br><span class="line">                    words = line.split()<span class="comment">#默认按照空格分词</span></span><br><span class="line">                    all_words += words</span><br><span class="line">    dictionary = Counter(all_words)</span><br><span class="line">    <span class="comment"># 词典构建好，删除多余的词汇</span></span><br><span class="line">    list_to_remove = list(dictionary.keys())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list_to_remove:</span><br><span class="line">        <span class="keyword">if</span> item.isalpha() == <span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">del</span> dictionary[item]</span><br><span class="line">        <span class="keyword">elif</span> len(item) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">del</span> dictionary[item]</span><br><span class="line">    dictionary = dictionary.most_common(n_dim)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dictionary</span><br></pre></td></tr></table></figure>
<p>构建完字典以后，就可以对每一封邮件进行编码了。特征向量的每一个分量即邮件中出现的对应词频。例如邮件“do over，do again”可以被编码为$[0,0,…,2,…,1,…,1]$。每一个分量都代表对应的词频。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将每个邮件转化为词频向量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_features</span><span class="params">(mail_dir)</span>:</span></span><br><span class="line">    </span><br><span class="line">    files = [os.path.join(mail_dir, f) <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(mail_dir)]</span><br><span class="line">    labels = np.ones(len(files))</span><br><span class="line">    feature_matrix = np.zeros((len(files), n_dim))</span><br><span class="line">    docID = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">with</span> open(file) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">if</span> f.name[<span class="number">30</span>:].find(<span class="string">"sp"</span>) != <span class="number">-1</span>:</span><br><span class="line">                <span class="comment">#垃圾邮件</span></span><br><span class="line">                labels[docID] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i, line <span class="keyword">in</span> enumerate(f):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">2</span>:</span><br><span class="line">                    words = line.split()</span><br><span class="line">                    <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">                        wordID = <span class="number">0</span></span><br><span class="line">                        <span class="keyword">for</span> i,d <span class="keyword">in</span> enumerate(dictionary):</span><br><span class="line">                            <span class="keyword">if</span>(d[<span class="number">0</span>] == w):</span><br><span class="line">                                wordID = i</span><br><span class="line">                                feature_matrix[docID, wordID] += <span class="number">1</span></span><br><span class="line">        docID += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> feature_matrix, labels</span><br></pre></td></tr></table></figure>
<h3 id="2-计算概率"><a href="#2-计算概率" class="headerlink" title="2 计算概率"></a>2 计算概率</h3><p>$P(word|y =spam) = P(word, spam) / P(spam)$，$P(word, spam)$即每个单词在垃圾邮件中出现的频数，$P(spam)$即垃圾邮件中所有单词的词频总和。正常邮件同理，得到概率矩阵。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计垃圾邮件中的所有词频和，以及各个词的频数</span></span><br><span class="line">spam_words = <span class="number">0</span></span><br><span class="line">non_spam_words = <span class="number">0</span></span><br><span class="line">spam_mails = []</span><br><span class="line">non_spam_mails = []</span><br><span class="line"><span class="keyword">for</span> i,line <span class="keyword">in</span> enumerate(feature_matrix):</span><br><span class="line">    <span class="keyword">if</span> labels[i] == <span class="number">1</span>:</span><br><span class="line">        non_spam_words += int(feature_matrix[i].sum())</span><br><span class="line">        non_spam_mails.append(feature_matrix[i])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        spam_mails.append(feature_matrix[i])</span><br><span class="line">        spam_words += int(feature_matrix[i].sum())</span><br><span class="line">print(<span class="string">"spam total words are &#123;&#125;, non-spam total words are &#123;&#125;"</span>.format(spam_words, non_spam_words))</span><br><span class="line"></span><br><span class="line">spam_mails = np.array(spam_mails)</span><br><span class="line">non_spam_mails = np.array(non_spam_mails)</span><br><span class="line"></span><br><span class="line">weight_matrix = np.zeros((<span class="number">2</span>,n_dim))</span><br><span class="line">weight_matrix[<span class="number">0</span>, :] = spam_mails.sum(axis = <span class="number">0</span>) / spam_words</span><br><span class="line">weight_matrix[<span class="number">1</span>, :] = non_spam_mails.sum(axis = <span class="number">0</span>) / non_spam_words</span><br></pre></td></tr></table></figure>
<p>为了避免概率矩阵中出现0的情况，使得计算概率时出现乘0，最后让权重矩阵每个分量加一个非常小的扰动</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sigma = <span class="number">1e-8</span></span><br><span class="line">weight_matrix += sigma</span><br></pre></td></tr></table></figure>
<h3 id="3-模型预测与评估"><a href="#3-模型预测与评估" class="headerlink" title="3 模型预测与评估"></a>3 模型预测与评估</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pred_labels = []</span><br><span class="line"><span class="keyword">for</span> feature <span class="keyword">in</span> test_feature:</span><br><span class="line">    spam_prob = <span class="number">1.0</span></span><br><span class="line">    non_spam_prob = <span class="number">1.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i,w <span class="keyword">in</span> enumerate(feature):</span><br><span class="line">        <span class="keyword">if</span> w != <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 计算P(w|spam) P(w|non-spam)</span></span><br><span class="line">            spam_prob += np.log10(weight_matrix[<span class="number">0</span>, i])</span><br><span class="line">            non_spam_prob += np.log10(weight_matrix[<span class="number">1</span>, i])</span><br><span class="line">    print(spam_prob, non_spam_prob)</span><br><span class="line">    <span class="keyword">if</span> spam_prob &gt; non_spam_prob:</span><br><span class="line">        pred_labels.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pred_labels.append(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>在计算概率的时候用到了一个trick，由于非常小的数不断连乘最后会趋于0，因此利用取对数的方法将乘法化为加法（极大似然估计就是这么干的）。同时取对数时不可以为0，上面加的非常小的扰动是很有必要的。</p>
<p>模型在测试集上的准确率、召回率、f1_score如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">recall_score : <span class="number">0.9923076923076923</span></span><br><span class="line">accuracy_score : <span class="number">0.9846153846153847</span></span><br><span class="line">f1_score : <span class="number">0.9847328244274809</span></span><br></pre></td></tr></table></figure>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      
      
    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-Strang教授线性代数笔记" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/23/Strang%E6%95%99%E6%8E%88%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0/"
    >Strang教授线性代数笔记</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/09/23/Strang%E6%95%99%E6%8E%88%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-09-23T02:44:37.995Z" itemprop="datePublished">2020-09-23</time>
</a>
      
      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h3 id="Strang教授线性代数笔记"><a href="#Strang教授线性代数笔记" class="headerlink" title="Strang教授线性代数笔记"></a>Strang教授线性代数笔记</h3><p>具体参见：<a href="https://github.com/zyj-nova/LinearAlgebraNotes" target="_blank" rel="noopener">https://github.com/zyj-nova/LinearAlgebraNotes</a></p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      
      
    </footer>

  </div>

  

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2019-2020
        张永剑
      </li>
      <li>
        
          Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <ul class="list-inline">
  <li>PV:<span id="busuanzi_value_page_pv"></span></li>
  <li>UV:<span id="busuanzi_value_site_uv"></span></li>
</ul>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="张永剑的博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>







<script>
  var ayerConfig = {
    mathjax: true
  }
</script>


<script src="/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>



<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>

</html>